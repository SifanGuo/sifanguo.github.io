---
layout: post
title:  "The Bandit Wargame"
date:   2019-04-18 11:43:24 +0800
categories: long
tag: linux
---

* content
{:toc}


This is the link for [Bandit wargame](http://overthewire.org/wargames/bandit/).


#### Bandit0
> The goal of this level is for you to log into the game using SSH. The host to which you need to connect is bandit.labs.overthewire.org, on port 2220. The username is bandit0 and the password is bandit0. Once logged in, go to the Level 1 page to find out how to beat Level 1.


#### Bandit1
>The password for the next level is stored in a file called *readme* located in the home directory. Use this password to log into bandit1 using SSH. Whenever you find a password for a level, use SSH (on port 2220) to log into that level and continue the game.

`Input: ls`

`Output: readme`

`Input: cat readme`

`Output: boJ9jbbUNNfktd78OOpsqOltutMc3MY1`

Here we go, we get the password for `bandi1`. I know it's weird to type every characters of the password. In fact, we could copy and paste the password when we log in by using `Ctrl + Shift + V`. It's worth noting that my putty doesn't work but the `Secure Shell App` from Google extension works.


#### Bandit2
> The password for the next level is stored in a file called - located in the home directory

`Input: ls`

`Output: -`

`Input: cat ./-`

`Output: CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9`

When "-" is the filename, we have to tell the system that this "-" is not the dash before parameters(for instance, `cat -n 7 filename`). Otherwise the system would wait for the input.


#### Bandit3
> The password for the next level is stored in a file called spaces in this filename located in the home directory

`Input: ls`

`Output: spaces in this filename`

`Input: cat "spaces in this filename"`

`Output: UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK`

Just like you have to add the quotes when you `git add "xxx xxx.file"`, we need to do that to tell the system this is a name of a file rather than separated commands.


#### Bandit4
> The password for the next level is stored in a hidden file in the inhere directory.

`Input: ls`

`Output: inhere`

`Input: cd inhere/`

`Input: ls -a`

`Output: .  ..  .hidden`

`Input: cat .hidden`

`Output: pIwrPrtPN36QITSp3EQaw936yaFoFgAB`

Basically, here we use the "-a" after ls to list all contents including the hidden files.


#### Bandit5
> The password for the next level is stored in the only human-readable file in the inhere directory. Tip: if your terminal is messed up, try the “reset” command.

`Input: ls`

`Output: inhere`

`Input: cd inhere/`

`Input: ls`

`Output: -file00  -file01  -file02  -file03  -file04  -file05  -file06  -file07  -file08  -file09`

`Input: cat ./-file07`

`Output: koReBOKuIDDepwhWk7jZC0RTdopnAYKh`

It says the file is human-readable only, I just check every file using `cat ./-file0x` and it turns out "-file07" has the password for bandit5.


#### Bandit6
> The password for the next level is stored in a file somewhere under the inhere directory and has all of the following properties: human-readable; 1033 bytes in size; not executable

`Input: ls`

`Output: inhere`

`Input: cd inhere/`

`Input: ls`

`Output:
maybehere00  maybehere02 ...... maybehere19
`

`Input: find -type f -size 1033c`

`Output: ./maybehere07/.file2`

`Input: cat ./maybehere07/.file2`

`Output: DXjZPULLxYr17uwoI01bNLQbtFemEgo7`

Using find command with "-type f", we can find file instead of directory (use "-type d"). Then with "-size 1033c", we get files whose size is 1033 Bytes.


#### Bandit7
> The password for the next level is stored somewhere on the server and has all of the following properties: owned by user bandit7; owned by group bandit6; 33 bytes in size


`Input: cd /`
change directory to the root

`Input: ls -Rla | grep "bandit7 bandit6"`

It returns a lot of lines, but we can find this line.

`Output: -rw-r----- 1 bandit7 bandit6      33 Oct 16  2018 bandit7.password`

`Input: find -name bandit7.password`

It returns a lot of lines, but we can find this line.

`Output:./var/lib/dpkg/info/bandit7.password`

`Input: cat ./var/lib/dpkg/info/bandit7.password`

`Output: HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs`

The `ls` command can be used with many parameters at once. The "R" means recursively find the sub-directories in addition to current work directory and the "l" means list the details of that file or folder.


#### Bandit8
> The password for the next level is stored in the file data.txt next to the word millionth

`Input: cat data.txt | grep millionth`

`Output: millionth       cvX2JJa4CFALtqS87jk27qwqGhBM9plV`

The password for bandit8 is cvX2JJa4CFALtqS87jk27qwqGhBM9plV.


#### Bandit9
> The password for the next level is stored in the file data.txt and is the only line of text that occurs only once.

`Input: sort data.txt | uniq -c | grep "1 "`

`Output:       1 UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR`

Or
`Input: sort data.txt | uniq -u`

`Output: UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR`


#### Bandit10
> The password for the next level is stored in the file data.txt in one of the few human-readable strings, beginning with several ‘=’ characters.

`Input: cat data.txt | grep ====`

`Output: Binary file (standard input) matches`

`Input: strings data.txt | grep ====`

`Output:
2========== the
========== password
========== isa
========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk`

When I use the `cat` command, it prompts that the file is a Binary one. Then we should use `strings` command because it returns each string of printable characters in files. Its main uses are to determine the contents of and to extract text from binary files (i.e., non-text files). The introduction page is [here](http://www.linfo.org/strings.html)


#### Bandit11
> The password for the next level is stored in the file data.txt, which contains base64 encoded data

`Input: cat data.txt | base64 -d`

`Output: The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR`

The `base64` command can encode a string without parameter and decode that with "-d".


#### Bandit12
> The password for the next level is stored in the file data.txt, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions

It's basically Caesar Cipher in this challenge. However, I didn't use my python script from last semester, cuz I want to try linux solution.

The `tr` command in UNIX is a command line utility for translating or deleting characters. It supports a range of transformations including uppercase to lowercase, squeezing repeating characters, deleting specific characters and basic find and replace. It can be used with UNIX pipes to support more complex translation. `tr` stands for translate.

Using `tr` command, we need to know what is the 14th letter of the alphabet (n). So it translate a to n, b to o and so on.

`Input: cat data.txt | tr a-zA-Z n-za-mN-ZA-M`

`Output: The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu`


#### Bandit13
> The password for the next level is stored in the file data.txt, which is a hexdump of a file that has been repeatedly compressed. For this level it may be useful to create a directory under /tmp in which you can work using mkdir. For example: mkdir /tmp/myname123. Then copy the datafile using cp, and rename it using mv (read the manpages!)

The `file` command can determine file type for a given file.

`Input: cp data.txt /tmp/sf/sfile`

`Input: cd /tmp/sf`

`Input: ls`

`Output: sfile`

`Input: file sfile`

`Output: sfile: ASCII text`

This file is a hexdump, so I have to do revert that transformation.

`Input: xxd -r sfile reverted`

`Input: ls`

`Output: reverted  sfile`

`Input: file reverted`

`Output: reverted: gzip compressed data, was "data2.bin", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix`

So we change the file name and unzip that 'gzip compressed data'.

`Input: mv reverted reverted.gz`

`Input: gzip -d reverted.gz`

`Input: ls`

`Output: reverted  sfile`

`Input: file reverted`

`Output: reverted: bzip2 compressed data, block size = 900k`

So we change the file name to bzip2 compressed data and unzip it.

`Input: mv reverted reverted.b2`

`Input: bzip2 -d reverted.b2`

`Output: bzip2: Can't guess original name for reverted.b2 -- using reverted.b2.out`

`Input: file reverted.b2.out`

`Output: reverted.b2.out: gzip compressed data, was "data4.bin"......`

Again, we change the file name to gz cuz it's gzip compressed.

`Input: mv reverted.b2.out reverted.gz`

`Input: gzip -d reverted.gz`

`Input: file reverted`

`Output: reverted: POSIX tar archive (GNU)`

The following process is basically the same, so I just screenshot the codes here.
![Screenshot]({{ '/styles/images/bandit13.jpg' | prepend: site.baseurl}})

`Input: cat data8`
`Output: The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL`


#### Bandit14
> The password for the next level is stored in /etc/bandit_pass/bandit14 and can only be read by user bandit14. For this level, you don’t get the next password, but you get a private SSH key that can be used to log into the next level. Note: localhost is a hostname that refers to the machine you are working on

`Input: ssh -i sshkey.private bandit14@localhost`
`Input: cat /etc/bandit_pass/bandit14`
`Output: 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e`


#### Bandit15
> The password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost.


`Input: cat /etc/bandit_pass/bandit14 | nc localhost 30000`

`Output: BfMYroe26WYalil77FoDi9qh59eK5xNr`


We can use `echo` or `cat` to talk to server:30000. Useful [resource here](https://www.computerhope.com/unix/nc.htm).


#### Bandit16
> The password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL encryption.




`Input: openssl s_client -connect localhost:30001`

`Output: CONNECTED(00000003).............---`

Then we enter the password for the current level.

`Input: BfMYroe26WYalil77FoDi9qh59eK5xNr`

`Output: Correct! cluFn7wTiGryunymYOu4RcffSxQluehd`


#### Bandit17
> The credentials for the next level can be retrieved by submitting the password of the current level to a port on localhost in the range 31000 to 32000. First find out which of these ports have a server listening on them. Then find out which of those speak SSL and which don’t. There is only 1 server that will give the next credentials, the others will simply send back to you whatever you send to it.


`Input: nmap localhost -p 31000-32000`

`Output: as follows`
![Screenshot]({{ '/styles/images/bandit17_1.jpg' | prepend: site.baseurl}})

As we can see from the screenshot, the port 31790 is open and other 1000 ports are closed. So we use openssl to connect to that port.

![Screenshot]({{ '/styles/images/bandit17_2.jpg' | prepend: site.baseurl}})

Because we cannot save file in the current folder, we need to change directory to /tmp/, and then we copy and paste the RSA key into a private key file. However when I input `ssh -i rsakey.private bandit17@localhost`, it prompts:

![Screenshot]({{ '/styles/images/bandit17_3.jpg' | prepend: site.baseurl}})

It says that we should not allow others to have right for this private key, with that saying, [here](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Step_by_Step_Guide/s1-navigating-ownership.html) is what I find useful for `chmod` command. I'd like to briefly introduce the `chmod` command: u for user (or the owner); g for group; o for others; a for all above; + adds the permission; - removes the permission; = makes the onley permission; r for read; w for write; x for execute.


`Input: ssh -i rsakey.private bandit17@localhost`

`Output: Enjoy your stay!`

#### Bandit18
> There are 2 files in the homedirectory: passwords.old and passwords.new. The password for the next level is in passwords.new and is the only line that has been changed between passwords.old and passwords.new


In order to get the difference of two files, I referred to [diff](https://www.geeksforgeeks.org/diff-command-linux-examples/) which is similar to `git diff`

`Input: diff passwords.new passwords.old`

`Output: 42c42`
`< kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd`
`---`
`> hlbSBPAWJmL6WFDb06gpTx1pPButblOA`


The "<" symbol indicates that this line `kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd` is from `passwords.new`, which means this string is the password for bandit18.


#### Bandit19
>The password for the next level is stored in a file readme in the homedirectory. Unfortunately, someone has modified .bashrc to log you out when you log in with SSH.


When I tried to login into bandit18@localhost, it says "Byebye" just after I logged in. So I searched on the Google and find this [answer](https://serverfault.com/questions/94503/login-without-running-bash-profile-or-bashrc). Then, I add the argument here:

![Screenshot]({{ '/styles/images/bandit19_1.jpg' | prepend: site.baseurl}})

`Input: cat readme`

`Output: IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x`

It's worth noting that the `-t` parameter opens a pseudo-tty( TeleTYpewriter, TTY), which might mean the .bashrc still runs when we open this session. However, we open the `shell` by typing `/bin/sh` as the input. I also tried to look for `-t` in the manual and I noticed that `-T` parameter can `Disable pseudo-terminal allocation`. I tried logged in using `-T` and I got the password as well, but I cannot see what I'm typing which looks like typing password in linux.

![Screenshot]({{ '/styles/images/bandit19_2.jpg' | prepend: site.baseurl}})

![Screenshot]({{ '/styles/images/bandit19_3.jpg' | prepend: site.baseurl}})


#### Bandit20
>To gain access to the next level, you should use the setuid binary in the homedirectory. Execute it without arguments to find out how to use it. The password for this level can be found in the usual place (/etc/bandit_pass), after you have used the setuid binary.




![Screenshot]({{ '/styles/images/bandit20.jpg' | prepend: site.baseurl}})

The password is `GbKksEFF4yrVs6il55v6gwY5aVje5f0j`.









[jekyll]:      http://jekyllrb.com
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-help]: https://github.com/jekyll/jekyll-help
